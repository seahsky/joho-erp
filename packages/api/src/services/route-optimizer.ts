/**
 * Route Optimizer Service
 * Business logic for calculating delivery routes and packing sequences
 */

import { prisma } from "@joho-erp/database";
import {
  optimizeRoutesByArea,
  calculateArrivalTimes,
} from "./mapbox";
import { sendRouteOptimizedEmail } from "./email";

interface RouteOptimizationResult {
  routeOptimizationId: string;
  orderUpdates: Array<{
    orderId: string;
    orderNumber: string;
    packingSequence: number;
    deliverySequence: number;
    estimatedArrival: Date;
    areaName: string;
  }>;
  routeSummary: {
    totalOrders: number;
    totalDistance: number;
    totalDuration: number;
    areaBreakdown: Array<{
      areaName: string;
      orderCount: number;
      distance: number;
      duration: number;
    }>;
  };
}

/**
 * Optimize delivery route and calculate packing/delivery sequences
 *
 * Strategy:
 * 1. Group orders by area (north, south, east, west)
 * 2. Optimize route within each area using Mapbox
 * 3. Calculate delivery sequence (1, 2, 3...)
 * 4. Calculate packing sequence (reverse of delivery, grouped by area)
 * 5. Store route optimization in database
 * 6. Update orders with sequences
 *
 * @param deliveryDate - Date to optimize deliveries for
 * @param userId - User performing the optimization
 * @returns Route optimization result with sequences
 */
export async function optimizeDeliveryRoute(
  deliveryDate: Date,
  userId: string
): Promise<RouteOptimizationResult> {
  // 1. Fetch company delivery settings (warehouse location)
  const company = await prisma.company.findFirst({
    select: {
      deliverySettings: true,
    },
  });

  if (!company?.deliverySettings) {
    throw new Error(
      "Delivery settings not configured. Please configure warehouse location in settings."
    );
  }

  const { warehouseAddress } = company.deliverySettings;

  // Get Mapbox token from environment variable
  const mapboxAccessToken = process.env.NEXT_PUBLIC_MAPBOX_TOKEN;

  if (!mapboxAccessToken) {
    throw new Error(
      "Mapbox access token not configured in environment variables. Please set NEXT_PUBLIC_MAPBOX_TOKEN."
    );
  }

  if (!warehouseAddress?.latitude || !warehouseAddress?.longitude) {
    throw new Error(
      "Warehouse location not configured. Please add coordinates in delivery settings."
    );
  }

  // 2. Fetch orders for the delivery date
  const startOfDay = new Date(deliveryDate);
  startOfDay.setHours(0, 0, 0, 0);

  const endOfDay = new Date(deliveryDate);
  endOfDay.setHours(23, 59, 59, 999);

  const orders = await prisma.order.findMany({
    where: {
      requestedDeliveryDate: {
        gte: startOfDay,
        lte: endOfDay,
      },
      status: {
        in: ["confirmed", "packing", "ready_for_delivery"],
      },
    },
    select: {
      id: true,
      orderNumber: true,
      deliveryAddress: true,
    },
  });

  if (orders.length === 0) {
    throw new Error("No orders found for the specified delivery date");
  }

  // 3. Validate all orders have coordinates
  const ordersWithoutCoordinates = orders.filter(
    (order) =>
      !order.deliveryAddress.latitude || !order.deliveryAddress.longitude
  );

  if (ordersWithoutCoordinates.length > 0) {
    const orderNumbers = ordersWithoutCoordinates
      .map((o) => o.orderNumber)
      .join(", ");
    throw new Error(
      `Orders missing coordinates: ${orderNumbers}. Please add address coordinates before optimizing.`
    );
  }

  // 4. Group orders by area
  const ordersByArea = new Map<
    string,
    Array<{
      id: string;
      orderNumber: string;
      longitude: number;
      latitude: number;
    }>
  >();

  for (const order of orders) {
    // Use 'unassigned' as fallback for orders without area
    const areaName = order.deliveryAddress.areaName ?? 'unassigned';
    if (!ordersByArea.has(areaName)) {
      ordersByArea.set(areaName, []);
    }
    ordersByArea.get(areaName)!.push({
      id: order.id,
      orderNumber: order.orderNumber,
      longitude: order.deliveryAddress.longitude!,
      latitude: order.deliveryAddress.latitude!,
    });
  }

  // 5. Optimize routes by area using Mapbox
  const warehouseCoord = {
    longitude: warehouseAddress.longitude,
    latitude: warehouseAddress.latitude,
  };

  const areaRoutes = await optimizeRoutesByArea(
    ordersByArea,
    warehouseCoord,
    mapboxAccessToken
  );

  // 6. Calculate sequences
  const orderUpdates: RouteOptimizationResult["orderUpdates"] = [];
  let globalDeliverySequence = 1;
  const areaBreakdown: RouteOptimizationResult["routeSummary"]["areaBreakdown"] =
    [];

  // Order of areas for packing (matches typical route order)
  const areaOrder: string[] = ["north", "east", "south", "west"];

  // Process areas in order
  for (const areaName of areaOrder) {
    const areaRoute = areaRoutes.get(areaName);
    if (!areaRoute) continue;

    const areaOrders = ordersByArea.get(areaName)!;
    const { coordinateIds, totalDistance, totalDuration, segments } = areaRoute;

    // Calculate arrival times (start at 9:00 AM, 5 min per stop)
    const routeStartTime = new Date(deliveryDate);
    routeStartTime.setHours(9, 0, 0, 0);
    const arrivalTimes = calculateArrivalTimes(routeStartTime, segments, 300);

    // Delivery sequence: in order of optimized route (1, 2, 3...)
    // Packing sequence: reverse within area for LIFO loading
    const areaOrderCount = coordinateIds.length;

    coordinateIds.forEach((orderId, index) => {
      const order = areaOrders.find((o) => o.id === orderId)!;
      const deliverySequence = globalDeliverySequence++;

      // Packing sequence: pack last delivery first within area
      // But maintain area grouping (all north packed before south, etc.)
      const packingSequence = areaOrderCount - index;

      orderUpdates.push({
        orderId: order.id,
        orderNumber: order.orderNumber,
        deliverySequence,
        packingSequence,
        estimatedArrival: arrivalTimes[index],
        areaName,
      });
    });

    areaBreakdown.push({
      areaName,
      orderCount: areaOrderCount,
      distance: totalDistance,
      duration: totalDuration,
    });
  }

  // 7. Adjust packing sequence to be global and grouped by area
  // Re-calculate packing sequence so areas are packed in reverse order
  let globalPackingSequence = 1;
  const areaOrderReversed = [...areaOrder].reverse(); // Pack south last (delivered first)

  for (const areaName of areaOrderReversed) {
    const areaOrderUpdates = orderUpdates.filter((u) => u.areaName === areaName);

    // Sort by delivery sequence ascending, then reverse for packing
    areaOrderUpdates.sort((a, b) => b.deliverySequence - a.deliverySequence);

    areaOrderUpdates.forEach((update) => {
      update.packingSequence = globalPackingSequence++;
    });
  }

  // 8. Calculate total route stats
  const totalDistance = areaBreakdown.reduce(
    (sum, area) => sum + area.distance,
    0
  );
  const totalDuration = areaBreakdown.reduce(
    (sum, area) => sum + area.duration,
    0
  );

  // 9. Combine all route geometries and waypoints
  const allWaypoints: Array<{
    orderId: string;
    orderNumber: string;
    sequence: number;
    address: string;
    latitude: number;
    longitude: number;
    estimatedArrival: Date;
    distanceFromPrevious?: number;
    durationFromPrevious?: number;
  }> = [];

  for (const [areaName, areaRoute] of areaRoutes.entries()) {
    const areaOrders = ordersByArea.get(areaName)!;
    const { coordinateIds, segments } = areaRoute;

    coordinateIds.forEach((orderId, index) => {
      const order = areaOrders.find((o) => o.id === orderId)!;
      const fullOrder = orders.find((o) => o.id === orderId)!;
      const update = orderUpdates.find((u) => u.orderId === orderId)!;

      allWaypoints.push({
        orderId: order.id,
        orderNumber: order.orderNumber,
        sequence: update.deliverySequence,
        address: `${fullOrder.deliveryAddress.street}, ${fullOrder.deliveryAddress.suburb}`,
        latitude: order.latitude,
        longitude: order.longitude,
        estimatedArrival: update.estimatedArrival,
        distanceFromPrevious: segments[index]?.distance,
        durationFromPrevious: segments[index]?.duration,
      });
    });
  }

  // Sort waypoints by delivery sequence
  allWaypoints.sort((a, b) => a.sequence - b.sequence);

  // 10. Create combined route geometry (for display purposes)
  // In reality, we'd stitch together the area routes, but for simplicity
  // we'll store the first area's geometry (or could store all separately)
  const firstRoute = Array.from(areaRoutes.values())[0];
  const routeGeometry = firstRoute?.routeGeometry || "{}";

  // 11. Store route optimization in database
  const routeOptimization = await prisma.routeOptimization.create({
    data: {
      deliveryDate: startOfDay,
      areaId: null, // Multi-area route
      orderCount: orders.length,
      totalDistance: totalDistance / 1000, // Convert meters to km
      totalDuration,
      routeGeometry,
      waypoints: allWaypoints.map((wp) => ({
        orderId: wp.orderId,
        orderNumber: wp.orderNumber,
        sequence: wp.sequence,
        address: wp.address,
        latitude: wp.latitude,
        longitude: wp.longitude,
        estimatedArrival: wp.estimatedArrival,
        distanceFromPrevious: wp.distanceFromPrevious,
        durationFromPrevious: wp.durationFromPrevious,
      })),
      optimizedAt: new Date(),
      optimizedBy: userId,
      mapboxRouteData: JSON.parse(JSON.stringify({
        areaRoutes: Array.from(areaRoutes.entries()).map(([area, route]) => ({
          area,
          totalDistance: route.totalDistance,
          totalDuration: route.totalDuration,
          orderCount: route.coordinateIds.length,
        })),
      })),
    },
  });

  // 12. Update orders with sequences
  await Promise.all(
    orderUpdates.map((update) =>
      prisma.order.update({
        where: { id: update.orderId },
        data: {
          packing: {
            packingSequence: update.packingSequence,
            packedItems: [],
          },
          delivery: {
            deliverySequence: update.deliverySequence,
            routeId: routeOptimization.id,
            estimatedArrival: update.estimatedArrival,
          },
        },
      })
    )
  );

  // 13. Send route optimized email notification
  const adminEmail = process.env.RESEND_ADMIN_EMAIL || 'admin@johofoods.com';
  await sendRouteOptimizedEmail({
    warehouseManagerEmail: adminEmail,
    warehouseManagerName: 'Warehouse Manager',
    deliveryDate,
    orderCount: orders.length,
    totalDistance: totalDistance / 1000, // Convert meters to km
    estimatedDuration: totalDuration / 60, // Convert seconds to minutes
  }).catch((error) => {
    console.error('Failed to send route optimized email:', error);
  });

  return {
    routeOptimizationId: routeOptimization.id,
    orderUpdates,
    routeSummary: {
      totalOrders: orders.length,
      totalDistance,
      totalDuration,
      areaBreakdown,
    },
  };
}

/**
 * Get existing route optimization for a delivery date
 */
export async function getRouteOptimization(deliveryDate: Date) {
  const startOfDay = new Date(deliveryDate);
  startOfDay.setHours(0, 0, 0, 0);

  const endOfDay = new Date(deliveryDate);
  endOfDay.setHours(23, 59, 59, 999);

  return prisma.routeOptimization.findFirst({
    where: {
      deliveryDate: {
        gte: startOfDay,
        lte: endOfDay,
      },
    },
    orderBy: {
      optimizedAt: "desc",
    },
  });
}

/**
 * Check if route needs re-optimization
 * (e.g., if orders were added/removed after last optimization)
 */
export async function checkIfRouteNeedsReoptimization(
  deliveryDate: Date
): Promise<boolean> {
  const route = await getRouteOptimization(deliveryDate);
  if (!route) return true;

  const startOfDay = new Date(deliveryDate);
  startOfDay.setHours(0, 0, 0, 0);

  const endOfDay = new Date(deliveryDate);
  endOfDay.setHours(23, 59, 59, 999);

  const currentOrderCount = await prisma.order.count({
    where: {
      requestedDeliveryDate: {
        gte: startOfDay,
        lte: endOfDay,
      },
      status: {
        in: ["confirmed", "packing", "ready_for_delivery"],
      },
    },
  });

  // If order count changed, re-optimization needed
  return currentOrderCount !== route.orderCount;
}


/**
 * Assigns a preliminary packing sequence to a newly confirmed order.
 * This gives the order an immediate sequence number (max + 1) without running
 * full route optimization. When the packer opens the packing session, full
 * optimization will recalculate optimal sequences based on geography.
 */
export async function assignPreliminaryPackingSequence(
  deliveryDate: Date,
  orderId: string
): Promise<number> {
  const startOfDay = new Date(deliveryDate);
  startOfDay.setUTCHours(0, 0, 0, 0);

  const endOfDay = new Date(deliveryDate);
  endOfDay.setUTCHours(23, 59, 59, 999);

  // Get max existing packing sequence for this delivery date
  const ordersWithSequence = await prisma.order.findMany({
    where: {
      requestedDeliveryDate: {
        gte: startOfDay,
        lte: endOfDay,
      },
      status: {
        in: ["confirmed", "packing", "ready_for_delivery"],
      },
      NOT: {
        id: orderId, // Exclude the current order
      },
    },
    select: {
      packing: true,
    },
  });

  const maxSequence = ordersWithSequence.reduce((max, order) => {
    const seq = order.packing?.packingSequence ?? 0;
    return seq > max ? seq : max;
  }, 0);

  const newSequence = maxSequence + 1;

  // Update the order with preliminary sequence
  await prisma.order.update({
    where: { id: orderId },
    data: {
      packing: {
        packingSequence: newSequence,
        packedItems: [],
      },
    },
  });

  return newSequence;
}

// ============================================================================
// DELIVERY ROUTE FUNCTIONS (for ready_for_delivery orders only)
// ============================================================================

interface DeliveryRouteResult {
  routeOptimizationId: string | null;
  orderUpdates: Array<{
    orderId: string;
    orderNumber: string;
    deliverySequence: number;
    estimatedArrival: Date;
    areaName: string;
  }>;
  routeSummary: {
    totalOrders: number;
    totalDistance: number;
    totalDuration: number;
    areaBreakdown: Array<{
      areaName: string;
      orderCount: number;
      distance: number;
      duration: number;
    }>;
  };
}

/**
 * Optimize delivery route for ONLY ready_for_delivery orders.
 * This is used to recalculate routes when viewing the delivery page,
 * ensuring only actually ready orders are included.
 *
 * @param deliveryDate - Date to optimize deliveries for
 * @param userId - User performing the optimization
 * @returns Route optimization result (or empty result if no ready orders)
 */
export async function optimizeDeliveryOnlyRoute(
  deliveryDate: Date,
  userId: string
): Promise<DeliveryRouteResult> {
  // 1. Fetch company delivery settings (warehouse location)
  const company = await prisma.company.findFirst({
    select: {
      deliverySettings: true,
    },
  });

  if (!company?.deliverySettings) {
    throw new Error(
      "Delivery settings not configured. Please configure warehouse location in settings."
    );
  }

  const { warehouseAddress } = company.deliverySettings;
  const mapboxAccessToken = process.env.NEXT_PUBLIC_MAPBOX_TOKEN;

  if (!mapboxAccessToken) {
    throw new Error(
      "Mapbox access token not configured in environment variables. Please set NEXT_PUBLIC_MAPBOX_TOKEN."
    );
  }

  if (!warehouseAddress?.latitude || !warehouseAddress?.longitude) {
    throw new Error(
      "Warehouse location not configured. Please add coordinates in delivery settings."
    );
  }

  // 2. Fetch ONLY ready_for_delivery orders
  const startOfDay = new Date(deliveryDate);
  startOfDay.setUTCHours(0, 0, 0, 0);

  const endOfDay = new Date(deliveryDate);
  endOfDay.setUTCHours(23, 59, 59, 999);

  const orders = await prisma.order.findMany({
    where: {
      requestedDeliveryDate: {
        gte: startOfDay,
        lte: endOfDay,
      },
      status: "ready_for_delivery", // ONLY ready orders
    },
    select: {
      id: true,
      orderNumber: true,
      deliveryAddress: true,
      delivery: true, // Include existing delivery data to preserve driver assignments
    },
  });

  // Return empty result if no ready orders (don't throw error)
  if (orders.length === 0) {
    return {
      routeOptimizationId: null,
      orderUpdates: [],
      routeSummary: {
        totalOrders: 0,
        totalDistance: 0,
        totalDuration: 0,
        areaBreakdown: [],
      },
    };
  }

  // 3. Validate all orders have coordinates
  const ordersWithoutCoordinates = orders.filter(
    (order) =>
      !order.deliveryAddress.latitude || !order.deliveryAddress.longitude
  );

  if (ordersWithoutCoordinates.length > 0) {
    const orderNumbers = ordersWithoutCoordinates
      .map((o) => o.orderNumber)
      .join(", ");
    throw new Error(
      `Orders missing coordinates: ${orderNumbers}. Please add address coordinates before optimizing.`
    );
  }

  // 4. Group orders by area
  const ordersByArea = new Map<
    string,
    Array<{
      id: string;
      orderNumber: string;
      longitude: number;
      latitude: number;
    }>
  >();

  for (const order of orders) {
    // Use 'unassigned' as fallback for orders without area
    const areaName = order.deliveryAddress.areaName ?? 'unassigned';
    if (!ordersByArea.has(areaName)) {
      ordersByArea.set(areaName, []);
    }
    ordersByArea.get(areaName)!.push({
      id: order.id,
      orderNumber: order.orderNumber,
      longitude: order.deliveryAddress.longitude!,
      latitude: order.deliveryAddress.latitude!,
    });
  }

  // 5. Optimize routes by area using Mapbox
  const warehouseCoord = {
    longitude: warehouseAddress.longitude,
    latitude: warehouseAddress.latitude,
  };

  const areaRoutes = await optimizeRoutesByArea(
    ordersByArea,
    warehouseCoord,
    mapboxAccessToken
  );

  // 6. Calculate delivery sequences (contiguous 1, 2, 3...)
  const orderUpdates: DeliveryRouteResult["orderUpdates"] = [];
  let globalDeliverySequence = 1;
  const areaBreakdown: DeliveryRouteResult["routeSummary"]["areaBreakdown"] = [];
  const areaOrder: string[] = ["north", "east", "south", "west"];

  for (const areaName of areaOrder) {
    const areaRoute = areaRoutes.get(areaName);
    if (!areaRoute) continue;

    const areaOrders = ordersByArea.get(areaName)!;
    const { coordinateIds, totalDistance, totalDuration, segments } = areaRoute;

    const routeStartTime = new Date(deliveryDate);
    routeStartTime.setHours(9, 0, 0, 0);
    const arrivalTimes = calculateArrivalTimes(routeStartTime, segments, 300);

    coordinateIds.forEach((orderId, index) => {
      const order = areaOrders.find((o) => o.id === orderId)!;
      const deliverySequence = globalDeliverySequence++;

      orderUpdates.push({
        orderId: order.id,
        orderNumber: order.orderNumber,
        deliverySequence,
        estimatedArrival: arrivalTimes[index],
        areaName,
      });
    });

    areaBreakdown.push({
      areaName,
      orderCount: coordinateIds.length,
      distance: totalDistance,
      duration: totalDuration,
    });
  }

  // 7. Calculate total route stats
  const totalDistance = areaBreakdown.reduce(
    (sum, area) => sum + area.distance,
    0
  );
  const totalDuration = areaBreakdown.reduce(
    (sum, area) => sum + area.duration,
    0
  );

  // 8. Build waypoints
  const allWaypoints: Array<{
    orderId: string;
    orderNumber: string;
    sequence: number;
    address: string;
    latitude: number;
    longitude: number;
    estimatedArrival: Date;
    distanceFromPrevious?: number;
    durationFromPrevious?: number;
  }> = [];

  for (const [areaName, areaRoute] of areaRoutes.entries()) {
    const areaOrders = ordersByArea.get(areaName)!;
    const { coordinateIds, segments } = areaRoute;

    coordinateIds.forEach((orderId, index) => {
      const order = areaOrders.find((o) => o.id === orderId)!;
      const fullOrder = orders.find((o) => o.id === orderId)!;
      const update = orderUpdates.find((u) => u.orderId === orderId)!;

      allWaypoints.push({
        orderId: order.id,
        orderNumber: order.orderNumber,
        sequence: update.deliverySequence,
        address: `${fullOrder.deliveryAddress.street}, ${fullOrder.deliveryAddress.suburb}`,
        latitude: order.latitude,
        longitude: order.longitude,
        estimatedArrival: update.estimatedArrival,
        distanceFromPrevious: segments[index]?.distance,
        durationFromPrevious: segments[index]?.duration,
      });
    });
  }

  allWaypoints.sort((a, b) => a.sequence - b.sequence);

  // 9. Get route geometry
  const firstRoute = Array.from(areaRoutes.values())[0];
  const routeGeometry = firstRoute?.routeGeometry || "{}";

  // 10. Store as delivery-type route
  const routeOptimization = await prisma.routeOptimization.create({
    data: {
      deliveryDate: startOfDay,
      routeType: "delivery", // Mark as delivery route
      driverId: null, // Global delivery route (not per-driver)
      areaId: null,
      orderCount: orders.length,
      totalDistance: totalDistance / 1000,
      totalDuration,
      routeGeometry,
      waypoints: allWaypoints.map((wp) => ({
        orderId: wp.orderId,
        orderNumber: wp.orderNumber,
        sequence: wp.sequence,
        address: wp.address,
        latitude: wp.latitude,
        longitude: wp.longitude,
        estimatedArrival: wp.estimatedArrival,
        distanceFromPrevious: wp.distanceFromPrevious,
        durationFromPrevious: wp.durationFromPrevious,
      })),
      optimizedAt: new Date(),
      optimizedBy: userId,
      mapboxRouteData: JSON.parse(JSON.stringify({
        areaRoutes: Array.from(areaRoutes.entries()).map(([area, route]) => ({
          area,
          totalDistance: route.totalDistance,
          totalDuration: route.totalDuration,
          orderCount: route.coordinateIds.length,
        })),
      })),
    },
  });

  // 11. Update orders with NEW delivery sequences (preserve existing delivery data)
  await Promise.all(
    orderUpdates.map((update) => {
      const existingOrder = orders.find((o) => o.id === update.orderId);
      const existingDelivery = existingOrder?.delivery || {};

      return prisma.order.update({
        where: { id: update.orderId },
        data: {
          delivery: {
            ...existingDelivery, // Preserve driverId, driverName, etc.
            deliverySequence: update.deliverySequence,
            routeId: routeOptimization.id,
            estimatedArrival: update.estimatedArrival,
          },
        },
      });
    })
  );

  // 12. Calculate per-driver sequences if drivers are assigned
  await calculatePerDriverSequences(deliveryDate);

  // NO email notification for delivery route (only for packing route)

  return {
    routeOptimizationId: routeOptimization.id,
    orderUpdates,
    routeSummary: {
      totalOrders: orders.length,
      totalDistance,
      totalDuration,
      areaBreakdown,
    },
  };
}

/**
 * Calculate per-driver delivery and packing sequences.
 * Groups orders by driverId and assigns contiguous sequences within each driver.
 *
 * @param deliveryDate - The delivery date to calculate sequences for
 */
export async function calculatePerDriverSequences(
  deliveryDate: Date
): Promise<void> {
  const startOfDay = new Date(deliveryDate);
  startOfDay.setUTCHours(0, 0, 0, 0);

  const endOfDay = new Date(deliveryDate);
  endOfDay.setUTCHours(23, 59, 59, 999);

  // Fetch all ready_for_delivery orders with their current sequences
  const orders = await prisma.order.findMany({
    where: {
      requestedDeliveryDate: {
        gte: startOfDay,
        lte: endOfDay,
      },
      status: "ready_for_delivery",
    },
    select: {
      id: true,
      delivery: true,
    },
    orderBy: {
      delivery: {
        deliverySequence: "asc",
      },
    },
  });

  if (orders.length === 0) return;

  // Group orders by driverId
  const ordersByDriver = new Map<string | null, typeof orders>();

  for (const order of orders) {
    const driverId = order.delivery?.driverId || null;
    if (!ordersByDriver.has(driverId)) {
      ordersByDriver.set(driverId, []);
    }
    ordersByDriver.get(driverId)!.push(order);
  }

  // Calculate per-driver sequences
  const updates: Array<{
    orderId: string;
    driverDeliverySequence: number;
    driverPackingSequence: number;
  }> = [];

  for (const [_driverId, driverOrders] of ordersByDriver.entries()) {
    // Sort by global delivery sequence (already sorted from query, but ensure)
    driverOrders.sort(
      (a, b) =>
        (a.delivery?.deliverySequence || 0) -
        (b.delivery?.deliverySequence || 0)
    );

    const orderCount = driverOrders.length;

    driverOrders.forEach((order, index) => {
      // Contiguous delivery sequence for this driver (1, 2, 3...)
      const driverDeliverySequence = index + 1;

      // LIFO packing sequence for this driver (reverse of delivery)
      const driverPackingSequence = orderCount - index;

      updates.push({
        orderId: order.id,
        driverDeliverySequence,
        driverPackingSequence,
      });
    });
  }

  // Update all orders with per-driver sequences
  await Promise.all(
    updates.map((update) =>
      prisma.order.update({
        where: { id: update.orderId },
        data: {
          delivery: {
            driverDeliverySequence: update.driverDeliverySequence,
            driverPackingSequence: update.driverPackingSequence,
          },
        },
      })
    )
  );
}

/**
 * Get existing delivery-type route optimization for a date
 *
 * @param deliveryDate - The delivery date
 * @param driverId - Optional: get route for specific driver
 */
export async function getDeliveryRouteOptimization(
  deliveryDate: Date,
  driverId?: string | null
) {
  const startOfDay = new Date(deliveryDate);
  startOfDay.setUTCHours(0, 0, 0, 0);

  const endOfDay = new Date(deliveryDate);
  endOfDay.setUTCHours(23, 59, 59, 999);

  const whereClause: {
    deliveryDate: { gte: Date; lte: Date };
    routeType: "delivery";
    driverId?: string | null;
  } = {
    deliveryDate: {
      gte: startOfDay,
      lte: endOfDay,
    },
    routeType: "delivery",
  };

  // If driverId is explicitly provided (including null for global routes)
  if (driverId !== undefined) {
    whereClause.driverId = driverId;
  }

  return prisma.routeOptimization.findFirst({
    where: whereClause,
    orderBy: {
      optimizedAt: "desc",
    },
  });
}

/**
 * Check if delivery route needs recalculation.
 * Returns true if:
 * - No delivery route exists for the date
 * - Ready order count changed since last calculation
 * - Driver assignments changed (tracked via order count mismatch)
 *
 * @param deliveryDate - The delivery date to check
 */
export async function checkIfDeliveryRouteNeedsRecalculation(
  deliveryDate: Date
): Promise<boolean> {
  const deliveryRoute = await getDeliveryRouteOptimization(deliveryDate, null);

  const startOfDay = new Date(deliveryDate);
  startOfDay.setUTCHours(0, 0, 0, 0);

  const endOfDay = new Date(deliveryDate);
  endOfDay.setUTCHours(23, 59, 59, 999);

  // Count current ready_for_delivery orders
  const currentReadyCount = await prisma.order.count({
    where: {
      requestedDeliveryDate: {
        gte: startOfDay,
        lte: endOfDay,
      },
      status: "ready_for_delivery",
    },
  });

  // If no delivery route exists, need to calculate
  if (!deliveryRoute) {
    return currentReadyCount > 0; // Only need recalc if there are ready orders
  }

  // If order count changed, need to recalculate
  if (currentReadyCount !== deliveryRoute.orderCount) {
    return true;
  }

  // Also check if the set of order IDs changed (more robust)
  const currentOrderIds = await prisma.order.findMany({
    where: {
      requestedDeliveryDate: {
        gte: startOfDay,
        lte: endOfDay,
      },
      status: "ready_for_delivery",
    },
    select: { id: true },
    orderBy: { id: "asc" },
  });

  const waypointOrderIds = deliveryRoute.waypoints
    .map((wp: { orderId: string }) => wp.orderId)
    .sort();
  const currentIds = currentOrderIds.map((o) => o.id).sort();

  // Check if same set of orders
  if (JSON.stringify(waypointOrderIds) !== JSON.stringify(currentIds)) {
    return true;
  }

  return false;
}
