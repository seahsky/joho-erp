// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "mongodb"
  url      = env("MONGODB_URI")
}

// ============================================================================
// ENUMS
// ============================================================================

enum ProductUnit {
  kg
  piece
  box
  carton
}

enum ProductStatus {
  active
  discontinued
  out_of_stock
}

enum ProductCategory {
  Beef
  Pork
  Chicken
  Lamb
  Processed
}

enum CustomerStatus {
  active
  suspended
  closed
}

enum CreditApplicationStatus {
  pending
  approved
  rejected
}

enum SignatureType {
  APPLICANT
  GUARANTOR
}

enum AccountType {
  sole_trader
  partnership
  company
  other
}

enum AustralianState {
  NSW
  VIC
  QLD
  SA
  WA
  TAS
  NT
  ACT
}

enum OrderStatus {
  awaiting_approval   // For backorders requiring admin approval
  confirmed
  packing
  ready_for_delivery
  out_for_delivery    // Driver has started delivery
  delivered
  cancelled
}

enum DeliveryReturnReason {
  customer_unavailable
  address_not_found
  refused_delivery
  damaged_goods
  other
}

enum RouteType {
  packing    // Initial route calculated during packing (all planned orders)
  delivery   // Final route for actual delivery (ready_for_delivery only)
}

enum ProofOfDeliveryType {
  signature
  photo
}

enum InventoryTransactionType {
  sale        // Automatic - order placed
  adjustment  // Manual - admin stock changes
  return      // Automatic - order cancelled
}

enum AdjustmentType {
  stock_received          // Adding stock from supplier delivery
  stock_count_correction  // Fixing discrepancy from stocktake
  stock_write_off         // Writing off damaged or expired inventory
  packing_adjustment      // Quantity adjusted during packing
  packing_reset           // Stock restored from packing reset
}

enum AuditAction {
  create
  update
  delete
  approve
  reject
}

enum SystemLogLevel {
  info
  warning
  error
  critical
}

enum InventoryReferenceType {
  order
  manual
}

enum XeroSyncJobType {
  sync_contact
  create_invoice
  create_credit_note
}

enum XeroSyncJobStatus {
  pending
  processing
  completed
  failed
}

enum SupplierStatus {
  active
  inactive
  pending_approval
  suspended
}

enum PaymentMethod {
  bank_transfer
  credit_card
  cheque
  cash_on_delivery
  account_credit
}

// ============================================================================
// MODELS
// ============================================================================

// Category Model
model Category {
  id                       String    @id @default(auto()) @map("_id") @db.ObjectId
  name                     String    @unique
  description              String?
  isActive                 Boolean   @default(true)
  processingLossPercentage Float?    // Optional: 0-100, processing loss % for internal operations
  createdAt                DateTime  @default(now())
  updatedAt                DateTime  @updatedAt

  // Relations
  products Product[]

  @@index([isActive])
  @@map("categories")
}

// Area Model - Configurable delivery areas (replaces AreaTag enum)
model Area {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  name          String   @unique  // Lowercase identifier: "north", "east-1", "east-2"
  displayName   String            // Human-readable: "North", "East 1", "East 2"
  colorVariant  String   @default("default")  // Badge color: "info", "success", "warning", "default", "secondary", "gray"
  isActive      Boolean  @default(true)
  sortOrder     Int      @default(0)  // For display ordering
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  suburbMappings    SuburbAreaMapping[]
  driverAssignments DriverAreaAssignment[]

  @@index([isActive, sortOrder])
  @@map("areas")
}

// Product Model
model Product {
  id                  String              @id @default(auto()) @map("_id") @db.ObjectId
  sku                 String              @unique
  name                String
  description         String?
  category            ProductCategory?    // Deprecated: Use categoryId instead
  categoryId          String?             @db.ObjectId
  categoryRelation    Category?           @relation(fields: [categoryId], references: [id])
  unit                ProductUnit
  packageSize         Float?
  basePrice           Int                 // Stored in cents (e.g., 2550 = $25.50)
  applyGst            Boolean             @default(false)
  gstRate             Float?              // GST rate as percentage (e.g., 10.0 for 10%)
  currentStock        Float               @default(0)
  lowStockThreshold   Float?
  status              ProductStatus       @default(active)
  xeroItemId          String?
  imageUrl            String?             // R2 public URL for product image
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  estimatedLossPercentage Float?          // Optional: 0-100, represents processing loss %

  // Subproduct relationship (self-referential)
  // parentProductId = null means regular product, set = subproduct
  // Note: MongoDB requires NoAction for self-relations; cascade handled in application
  parentProductId     String?             @db.ObjectId
  parentProduct       Product?            @relation("ProductSubproducts", fields: [parentProductId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  subProducts         Product[]           @relation("ProductSubproducts")

  // Relations
  inventoryTransactions InventoryTransaction[]
  customerPricing     CustomerPricing[]
  batches             InventoryBatch[]
  suppliers           ProductSupplier[]     // Suppliers for this product

  // Indexes
  @@index([status])
  @@index([category])
  @@index([categoryId])
  @@index([name])
  @@index([currentStock, lowStockThreshold])
  @@index([parentProductId])
  @@map("products")
}

// Supplier Model
model Supplier {
  id                  String              @id @default(auto()) @map("_id") @db.ObjectId

  // Business Information
  supplierCode        String              @unique
  businessName        String
  tradingName         String?
  abn                 String?             // Australian Business Number
  acn                 String?             // Australian Company Number

  // Contact Information
  primaryContact      SupplierContact
  secondaryContact    SupplierContact?
  accountsContact     SupplierContact?    // For invoicing/payments

  // Address
  businessAddress     SupplierAddress
  deliveryAddress     SupplierAddress?    // If different from business

  // Financial Terms (ALL IN CENTS)
  paymentTerms        String?             // e.g., "Net 30", "COD"
  paymentMethod       PaymentMethod       @default(account_credit)
  creditLimit         Int                 @default(0)        // In cents
  currentBalance      Int                 @default(0)        // In cents
  bankDetails         SupplierBankDetails?

  // Delivery Terms
  minimumOrderValue   Int?                                   // In cents
  minimumOrderQty     Float?
  leadTimeDays        Int?                // Standard lead time in days
  deliveryDays        String?             // e.g., "Mon, Wed, Fri"
  deliveryNotes       String?

  // Product Categories (what they supply)
  primaryCategories   String[]            // e.g., ["Beef", "Lamb"]

  // Performance & Compliance
  qualityRating       Float?              // 0-5 stars (optional)
  onTimeDeliveryRate  Float?              // 0-100 percentage
  foodSafetyLicense   String?
  licenseExpiry       DateTime?
  insuranceExpiry     DateTime?

  // Status & Metadata
  status              SupplierStatus      @default(active)
  suspensionReason    String?             // Required if suspended
  suspendedAt         DateTime?
  suspendedBy         String?             // User who suspended
  internalNotes       String?

  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  createdBy           String              // Clerk user ID

  // Relations
  products            ProductSupplier[]   // Many-to-many with products
  inventoryBatches    InventoryBatch[]    // Batches received from supplier

  // Indexes (supplierCode already indexed via @unique)
  @@index([status])
  @@index([businessName])
  @@index([primaryCategories])
  @@index([createdAt(sort: Desc)])
  @@index([status, createdAt(sort: Desc)])  // Filtered list queries
  @@index([businessName, status])           // Search with filter
  @@map("suppliers")
}

// ProductSupplier Junction Model - Links products to suppliers with cost tracking
model ProductSupplier {
  id                  String              @id @default(auto()) @map("_id") @db.ObjectId
  productId           String              @db.ObjectId
  supplierId          String              @db.ObjectId

  // Product-specific supplier details
  supplierSku         String?             // Supplier's SKU for this product
  supplierProductName String?             // Supplier's name for product
  costPrice           Int                 // In cents - current cost
  lastCostPrice       Int?                // In cents - previous cost for comparison

  // Ordering
  packSize            Float?              // How product is packed by supplier
  moq                 Float?              // Minimum order quantity
  leadTimeDays        Int?                // Product-specific lead time

  // Performance & Status
  isPreferredSupplier Boolean             @default(false)
  lastOrderDate       DateTime?
  lastReceiveDate     DateTime?
  totalOrdersCount    Int                 @default(0)
  isActive            Boolean             @default(true)
  discontinuedAt      DateTime?

  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt

  // Relations
  product             Product             @relation(fields: [productId], references: [id], onDelete: Cascade)
  supplier            Supplier            @relation(fields: [supplierId], references: [id], onDelete: Cascade)

  // Constraints & Indexes
  @@unique([productId, supplierId])       // One record per product-supplier pair
  @@index([supplierId, isActive])
  @@index([productId, isActive])
  @@index([isPreferredSupplier])
  @@map("productsuppliers")
}

// Customer Model
model Customer {
  id                  String              @id @default(auto()) @map("_id") @db.ObjectId
  clerkUserId         String              @unique
  accountType         AccountType         @default(company)
  businessName        String
  tradingName         String?
  abn                 String
  acn                 String?
  contactPerson       ContactPerson
  deliveryAddress     DeliveryAddress
  billingAddress      BillingAddress?
  postalAddress       BillingAddress?
  creditApplication   CreditApplication
  directors           DirectorDetails[]
  financialDetails    FinancialDetails?
  tradeReferences     TradeReference[]
  smsReminderPreferences SmsReminderPreferences?
  status              CustomerStatus      @default(active)
  suspensionReason    String?             // Reason for suspension (if suspended)
  suspendedAt         DateTime?           // When account was suspended
  suspendedBy         String?             // User ID of admin who suspended
  closureReason       String?             // Reason for account closure (if closed)
  closedAt            DateTime?           // When account was closed
  closedBy            String?             // User ID of admin who closed the account
  xeroContactId       String?
  onboardingComplete  Boolean             @default(false)
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt

  // Relations
  orders              Order[]
  customerPricing     CustomerPricing[]
  cart                Cart?               // Persistent shopping cart (one per customer)

  // Indexes
  @@index([contactPerson.email])
  @@index([deliveryAddress.areaId])
  @@index([creditApplication.status])
  @@index([status])
  @@index([businessName])
  @@index([abn])
  @@index([accountType])
  @@index([xeroContactId])
  @@map("customers")
}

// Order Model
model Order {
  id                      String              @id @default(auto()) @map("_id") @db.ObjectId
  orderNumber             String              @unique
  customerId              String              @db.ObjectId
  customerName            String
  items                   OrderItem[]
  subtotal                Int                 // Stored in cents
  taxAmount               Int                 // Stored in cents
  totalAmount             Int                 // Stored in cents
  deliveryAddress         DeliveryAddress
  requestedDeliveryDate   DateTime
  status                  OrderStatus         @default(confirmed)
  statusHistory           StatusHistory[]
  packing                 Packing?
  delivery                Delivery?
  internalNotes           String?
  xero                    XeroInfo?
  orderedAt               DateTime            @default(now())
  createdBy               String
  createdAt               DateTime            @default(now())
  updatedAt               DateTime            @updatedAt

  // Admin order fields
  bypassCreditLimit       Boolean             @default(false)
  bypassCreditReason      String?
  bypassCutoffTime        Boolean             @default(false)
  bypassMinimumOrder      Boolean             @default(false)
  useCustomAddress        Boolean             @default(false)
  customDeliveryAddress   DeliveryAddress?
  adminNotes              String?
  placedOnBehalfOf        String?             // Customer ID when admin places order
  placedByAdmin           String?             // Admin user ID who placed the order

  // Backorder fields (backorder decision inferred from stockShortfall + approvedQuantities + status)
  stockShortfall          Json?               // {productId: {requested: X, available: Y, shortfall: Z}}
  approvedQuantities      Json?               // {productId: approvedQty} - For partial approvals
  backorderNotes          String?             // Admin notes on approval/rejection
  expectedFulfillment     DateTime?           // Expected date when stock will arrive
  reviewedBy              String?             // Admin who approved/rejected
  reviewedAt              DateTime?           // When backorder was reviewed

  // Stock consumption tracking (for idempotent packing workflow)
  stockConsumed           Boolean             @default(false)  // True after markOrderReady succeeds
  stockConsumedAt         DateTime?                            // When stock was consumed
  version                 Int                 @default(0)      // Optimistic locking for concurrent updates

  // Relations
  customer                Customer            @relation(fields: [customerId], references: [id])

  // Indexes
  @@index([customerId, orderedAt(sort: Desc)])
  @@index([status, requestedDeliveryDate])
  @@index([deliveryAddress.areaId, requestedDeliveryDate])
  @@index([requestedDeliveryDate, status])
  @@index([delivery.driverId, status])
  @@index([orderedAt(sort: Desc)])
  @@index([xero.invoiceId])
  @@index([createdAt(sort: Desc)])
  @@index([status, stockShortfall, createdAt(sort: Desc)])  // For backorder queries
  @@map("orders")
}

// Customer Pricing Model
model CustomerPricing {
  id                  String              @id @default(auto()) @map("_id") @db.ObjectId
  customerId          String              @db.ObjectId
  productId           String              @db.ObjectId
  customPrice         Int                 // Stored in cents
  effectiveFrom       DateTime            @default(now())
  effectiveTo         DateTime?
  notes               String?             // Notes about the pricing (e.g., "Contract pricing until Dec 2025")
  createdBy           String?             // User ID of admin who created/updated the pricing
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt

  // Relations
  customer            Customer            @relation(fields: [customerId], references: [id])
  product             Product             @relation(fields: [productId], references: [id])

  // Indexes
  @@unique([customerId, productId])
  @@index([productId])
  @@index([effectiveTo])
  @@map("customerpricing")
}

// Inventory Transaction Model
model InventoryTransaction {
  id                  String                      @id @default(auto()) @map("_id") @db.ObjectId
  productId           String                      @db.ObjectId
  type                InventoryTransactionType
  adjustmentType      AdjustmentType?             // Only set when type='adjustment'
  quantity            Float
  previousStock       Float
  newStock            Float
  referenceType       InventoryReferenceType?     // 'order' for sales/returns, 'manual' for adjustments
  referenceId         String?                     @db.ObjectId
  notes               String?
  createdBy           String
  createdAt           DateTime                    @default(now())
  updatedAt           DateTime                    @updatedAt
  reversedAt          DateTime?                   // When this transaction was reversed/cancelled

  // Batch costing fields (only for stock_received transactions)
  costPerUnit         Int?                        // In cents - cost when receiving stock
  expiryDate          DateTime?                   // Expiry date when receiving stock

  // Relations
  product             Product                     @relation(fields: [productId], references: [id])
  batchConsumptions   BatchConsumption[]          // Track which batches were affected

  // Indexes
  @@index([productId, createdAt(sort: Desc)])
  @@index([referenceId, referenceType])
  @@index([type])
  @@index([adjustmentType])
  @@index([createdAt(sort: Desc), type])
  @@index([reversedAt])
  @@map("inventorytransactions")
}

// Inventory Batch Model - Tracks cost per batch with FIFO consumption
model InventoryBatch {
  id                  String              @id @default(auto()) @map("_id") @db.ObjectId
  productId           String              @db.ObjectId
  supplierId          String?             @db.ObjectId  // Optional supplier reference

  // Batch tracking
  quantityRemaining   Float               // Current available quantity
  initialQuantity     Float               // Original quantity received (for reporting)
  costPerUnit         Int                 // In cents - cost per unit when received

  // FIFO and expiry tracking
  receivedAt          DateTime            @default(now())
  expiryDate          DateTime?           // Critical for food safety - nullable for non-perishables

  // Traceability
  receiveTransactionId String?            @db.ObjectId  // Link to InventoryTransaction that created this batch
  notes               String?             // Admin notes (e.g., "Supplier: ABC Meats, Invoice: #12345")

  // NEW: Enhanced traceability and compliance fields
  supplierInvoiceNumber String?           // Supplier invoice reference for reconciliation
  stockInDate           DateTime?         // User-entered actual receipt date (vs auto receivedAt)
  mtvNumber             String?           // PrimeSafe Meat Transfer Vehicle license number
  vehicleTemperature    Float?            // Celsius - delivery temperature for food safety

  // Soft delete for audit trail
  isConsumed          Boolean             @default(false)  // True when quantityRemaining = 0
  consumedAt          DateTime?           // When fully consumed

  // Timestamps
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt

  // Relations
  product             Product             @relation(fields: [productId], references: [id], onDelete: Cascade)
  supplier            Supplier?           @relation(fields: [supplierId], references: [id])
  consumptions        BatchConsumption[]  // Track which orders consumed from this batch

  // Indexes for FIFO performance
  @@index([productId, receivedAt])        // FIFO order lookup
  @@index([productId, expiryDate])        // Expiry warnings
  @@index([productId, isConsumed])        // Active batches only
  @@index([expiryDate, isConsumed])       // Global expiry warnings
  @@index([supplierId])                   // Supplier lookup
  @@map("inventorybatches")
}

// Batch Consumption Model - Tracks which batches were consumed for COGS calculation
model BatchConsumption {
  id                  String              @id @default(auto()) @map("_id") @db.ObjectId
  batchId             String              @db.ObjectId
  transactionId       String              @db.ObjectId

  // Consumption details
  quantityConsumed    Float               // How much was taken from this batch
  costPerUnit         Int                 // In cents - cost at time of consumption (denormalized from batch)
  totalCost           Int                 // In cents - quantityConsumed * costPerUnit (for quick COGS)

  // Reference
  orderId             String?             @db.ObjectId  // If consumed by an order
  orderNumber         String?             // Denormalized for easy lookup

  consumedAt          DateTime            @default(now())
  createdAt           DateTime            @default(now())

  // Relations
  batch               InventoryBatch      @relation(fields: [batchId], references: [id], onDelete: Cascade)
  transaction         InventoryTransaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  // Indexes
  @@index([batchId])
  @@index([transactionId])
  @@index([orderId])
  @@index([consumedAt(sort: Desc)])
  @@map("batchconsumptions")
}

// Audit Log Model
model AuditLog {
  id                  String              @id @default(auto()) @map("_id") @db.ObjectId
  userId              String
  userEmail           String?             // Email of the user who performed the action
  userRole            String?             // Role of the user (admin, sales, packer, driver, manager)
  userName            String?             // Display name of the user who performed the action
  action              AuditAction
  entity              String
  entityId            String?             @db.ObjectId
  changes             Json?
  metadata            Json?
  ipAddress           String?
  userAgent           String?
  timestamp           DateTime            @default(now())

  // Indexes
  @@index([userId, timestamp(sort: Desc)])
  @@index([entity, entityId, timestamp(sort: Desc)])
  @@index([action, timestamp(sort: Desc)])
  @@index([timestamp(sort: Desc)])
  @@index([userRole, timestamp(sort: Desc)])
  @@map("auditlogs")
}

// ============================================================================
// RBAC MODELS
// ============================================================================

// Permission definition - stores all available permissions in the system
model Permission {
  id          String   @id @default(auto()) @map("_id") @db.ObjectId
  module      String   // e.g., "customers", "orders", "products"
  action      String   // e.g., "view", "create", "edit", "delete"
  code        String   @unique // e.g., "customers:view", "orders:create"
  description String?  // Human-readable description
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  rolePermissions RolePermission[]

  @@unique([module, action])
  @@index([module])
  @@index([isActive])
  @@map("permissions")
}

// Role-Permission mapping - which roles have which permissions
model RolePermission {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  role         String   // e.g., "admin", "sales", "manager"
  permissionId String   @db.ObjectId
  grantedAt    DateTime @default(now())
  grantedBy    String?  // User ID who granted the permission

  // Relations
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@unique([role, permissionId])
  @@index([role])
  @@index([permissionId])
  @@map("role_permissions")
}

// System Log Model
model SystemLog {
  id                  String              @id @default(auto()) @map("_id") @db.ObjectId
  level               SystemLogLevel
  message             String
  service             String
  context             Json?
  stack               String?
  timestamp           DateTime            @default(now())

  // Indexes
  @@index([level, timestamp(sort: Desc)])
  @@index([service, timestamp(sort: Desc)])
  @@index([timestamp(sort: Desc)])
  @@map("systemlogs")
}

// Company Model (Singleton)
model Company {
  id                      String                  @id @default(auto()) @map("_id") @db.ObjectId
  businessName            String
  abn                     String
  email                   String?                 // Company contact email
  phone                   String?                 // Company contact phone
  address                 CompanyAddress
  contactPerson           ContactPerson
  bankDetails             BankDetails?
  xeroSettings            XeroSettings?
  deliverySettings        DeliverySettings?
  notificationSettings    NotificationSettings?
  smsSettings             SmsSettings?
  packingSettings         PackingSettings?
  inventorySettings       InventorySettings?
  logoUrl                 String?
  createdAt               DateTime                @default(now())
  updatedAt               DateTime                @updatedAt

  @@map("company")
}

// Suburb Area Mapping Model
model SuburbAreaMapping {
  id                  String              @id @default(auto()) @map("_id") @db.ObjectId
  suburb              String
  state               String
  postcode            String

  // Reference to Area model
  areaId              String?             @db.ObjectId
  area                Area?               @relation(fields: [areaId], references: [id])

  latitude            Float?              // Suburb center latitude for route optimization
  longitude           Float?              // Suburb center longitude for route optimization
  isActive            Boolean             @default(true) // Whether this suburb is actively serviced
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt

  // Indexes
  @@unique([suburb, state])
  @@index([postcode])
  @@index([areaId])
  @@index([isActive])
  @@map("suburbareamappings")
}

// Driver Area Assignment Model
// Maps drivers to their assigned delivery areas for auto-assignment
model DriverAreaAssignment {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  driverId  String   // Clerk user ID

  // Reference to Area model
  areaId    String?  @db.ObjectId
  area      Area?    @relation(fields: [areaId], references: [id])

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([driverId, areaId])
  @@index([areaId])
  @@index([driverId])
  @@map("driverareaassignments")
}

// Xero Sync Job Model
model XeroSyncJob {
  id                  String              @id @default(auto()) @map("_id") @db.ObjectId
  type                XeroSyncJobType
  status              XeroSyncJobStatus   @default(pending)
  entityType          String              // 'customer' | 'order'
  entityId            String              @db.ObjectId
  payload             Json?
  attempts            Int                 @default(0)
  maxAttempts         Int                 @default(3)
  lastAttemptAt       DateTime?
  nextAttemptAt       DateTime?
  error               String?
  result              Json?
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  completedAt         DateTime?

  @@index([status, nextAttemptAt])
  @@index([entityType, entityId])
  @@index([type, status])
  @@map("xerosyncjobs")
}

// Route Optimization Model
model RouteOptimization {
  id                  String              @id @default(auto()) @map("_id") @db.ObjectId
  deliveryDate        DateTime
  routeType           RouteType           @default(packing) // packing = all planned orders, delivery = ready_for_delivery only
  driverId            String?             // For per-driver delivery routes (null for global routes)

  // Area reference
  areaId              String?             @db.ObjectId // Null if multi-area route

  orderCount          Int
  totalDistance       Float               // In kilometers
  totalDuration       Int                 // In seconds
  routeGeometry       String              // GeoJSON LineString from Mapbox
  waypoints           RouteWaypoint[]     // Ordered list of delivery stops
  optimizedAt         DateTime            @default(now())
  optimizedBy         String
  mapboxRouteData     Json?               // Full Mapbox API response for reference
  needsReoptimization Boolean             @default(false) // Flag when orders changed since optimization
  lastOrderCount      Int?                // Order count at last optimization (to detect changes)
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt

  // Indexes
  @@index([deliveryDate, areaId])
  @@index([deliveryDate, routeType])
  @@index([deliveryDate, routeType, driverId])
  @@index([optimizedAt(sort: Desc)])
  @@index([needsReoptimization, deliveryDate])
  @@map("routeoptimizations")
}

// Packing Session Model - Tracks active packing sessions for timeout management
model PackingSession {
  id                  String              @id @default(auto()) @map("_id") @db.ObjectId
  packerId            String              // Clerk user ID of the packer
  deliveryDate        DateTime            // The delivery date being packed
  orderIds            String[]            @db.ObjectId // Orders being packed in this session
  status              PackingSessionStatus @default(active)
  startedAt           DateTime            @default(now())
  lastActivityAt      DateTime            @default(now())
  endedAt             DateTime?
  endReason           PackingSessionEndReason?
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt

  // Indexes
  @@index([packerId, status])
  @@index([deliveryDate, status])
  @@index([lastActivityAt, status])
  @@index([status])
  @@map("packingsessions")
}

enum PackingSessionStatus {
  active              // Session is active
  completed           // Packer finished normally
  timed_out           // Session exceeded 30 min inactivity
  cancelled           // Manually cancelled
}

enum PackingSessionEndReason {
  all_orders_packed   // All orders marked ready for delivery
  manual_end          // Packer ended session manually
  timeout             // 30 minute inactivity timeout
  new_session_started // Another session was started for same date
}

// Cart Model - Persistent shopping cart storage
model Cart {
  id          String      @id @default(auto()) @map("_id") @db.ObjectId
  customerId  String      @unique @db.ObjectId
  items       CartItem[]
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // Relations
  customer    Customer    @relation(fields: [customerId], references: [id], onDelete: Cascade)

  @@index([updatedAt(sort: Desc)])
  @@map("carts")
}

// ============================================================================
// COMPOSITE TYPES (Embedded Documents)
// ============================================================================

type ContactPerson {
  firstName           String
  lastName            String
  email               String
  phone               String
  mobile              String?
}

type DeliveryAddress {
  street              String
  suburb              String
  state               String
  postcode            String
  country             String              @default("Australia")

  // Area reference (areaId stored, areaName denormalized for display)
  areaId              String?             // Reference to Area model (null = unassigned)
  areaName            String?             // Denormalized area name for display (e.g., "north", "east-1")

  latitude            Float?
  longitude           Float?
  deliveryInstructions String?
}

type BillingAddress {
  street              String
  suburb              String
  state               String
  postcode            String
  country             String              @default("Australia")
}

type CreditApplication {
  status              CreditApplicationStatus @default(pending)
  requestedCreditLimit Int?                // Stored in cents
  forecastPurchase    Int?                // Stored in cents
  appliedAt           DateTime            @default(now())
  submittedAt         DateTime?
  reviewedAt          DateTime?
  reviewedBy          String?
  creditLimit         Int                 @default(0) // Stored in cents
  paymentTerms        String?
  notes               String?
  signatures          CreditSignature[]   // All signatures for this application
  agreedToTermsAt     DateTime?           // When T&C were agreed
}

type CreditSignature {
  signerName          String              // Full name of the signer
  signerPosition      String?             // Position/role (e.g., "Director")
  signatureUrl        String              // R2 public URL to signature image
  signedAt            DateTime            // When the signature was captured
  signatureType       SignatureType       // APPLICANT or GUARANTOR
  witnessName         String?             // For guarantor signatures only
  witnessSignatureUrl String?             // Witness signature URL (for guarantor)
  witnessSignedAt     DateTime?           // When witness signed
}

type OrderItem {
  productId               String              @db.ObjectId
  sku                     String
  productName             String
  unit                    String
  quantity                Float
  unitPrice               Int                 // Stored in cents
  subtotal                Int                 // Stored in cents
  applyGst                Boolean             @default(false)
  gstRate                 Float?              // GST rate as percentage (e.g., 10.0 for 10%)
  estimatedLossPercentage Float?              // Snapshot of product's loss % at order time (for subproducts)
}

type CartItem {
  productId           String              @db.ObjectId
  sku                 String
  productName         String
  unit                String
  quantity            Int                 // Cart quantities are always integers
  unitPrice           Int                 // In cents (effective price with customer-specific discount, before GST)
  basePrice           Int                 // In cents (original price, before GST)
  subtotal            Int                 // In cents (unitPrice * quantity, before GST)
  hasCustomPricing    Boolean             @default(false)
  applyGst            Boolean             @default(false)
  gstRate             Float               @default(10)  // GST rate percentage
  itemGst             Int                 // In cents (calculated GST for this item)
  itemTotal           Int                 // In cents (subtotal + itemGst)
  imageUrl            String?             // Product image URL
  description         String?             // Product description
}

type StatusHistory {
  status              String
  changedAt           DateTime            @default(now())
  changedBy           String
  changedByName       String?
  changedByEmail      String?
  notes               String?
}

type Packing {
  packedAt            DateTime?
  packedBy            String?
  notes               String?
  packingSequence     Int?                // Position in packing queue (1 = pack first)
  packedItems         String[]            // Array of SKUs that have been packed
  // Partial progress persistence fields
  lastPackedAt        DateTime?           // When packing was last updated
  lastPackedBy        String?             // Who last worked on this order (user ID)
  pausedAt            DateTime?           // When packing was paused (null if active)
  // Original order items snapshot - stored on first quantity adjustment for reset capability
  originalItems       OriginalOrderItem[]
}

// Snapshot of original order item for reset capability
type OriginalOrderItem {
  productId           String
  sku                 String
  quantity            Int
  unitPrice           Int                 // Stored in cents
  subtotal            Int                 // Stored in cents
}

type Delivery {
  driverId            String?
  driverName          String?
  assignedAt          DateTime?
  startedAt           DateTime?           // When driver marked "out for delivery"
  deliveredAt         DateTime?
  proofOfDelivery     ProofOfDelivery?
  notes               String?
  deliverySequence    Int?                // Position in global delivery route (1 = first stop)
  routeId             String?             // Reference to RouteOptimization
  estimatedArrival    DateTime?           // Estimated arrival time based on route
  actualArrival       DateTime?           // Actual arrival time (for analytics)
  // Per-driver sequences (for multi-driver scenarios)
  driverDeliverySequence Int?             // Contiguous sequence within driver's route (1,2,3...)
  driverPackingSequence  Int?             // LIFO sequence for this driver's vehicle
  // Return fields (when driver returns order to warehouse)
  returnReason        DeliveryReturnReason?
  returnNotes         String?
  returnedAt          DateTime?
}

type ProofOfDelivery {
  type                ProofOfDeliveryType
  fileUrl             String
  uploadedAt          DateTime
}

type XeroInfo {
  invoiceId           String?
  invoiceNumber       String?
  invoiceStatus       String?
  creditNoteId        String?
  creditNoteNumber    String?
  syncedAt            DateTime?
  syncError           String?
  lastSyncJobId       String?
}

type CompanyAddress {
  street              String
  suburb              String
  state               String
  postcode            String
  country             String              @default("Australia")
}

type BankDetails {
  bankName            String
  accountName         String
  bsb                 String
  accountNumber       String
}

// Supplier-related composite types
type SupplierContact {
  name                String
  position            String?
  email               String
  phone               String
  mobile              String?
}

type SupplierAddress {
  street              String
  suburb              String
  state               AustralianState
  postcode            String
  country             String              @default("Australia")
}

type SupplierBankDetails {
  accountName         String
  bsb                 String
  accountNumber       String
  bankName            String?
}

type XeroSettings {
  clientId            String
  clientSecret        String
  tenantId            String?
  refreshToken        String?
  tokenExpiry         DateTime?
  accessToken         String?
}

type DirectorDetails {
  familyName              String
  givenNames              String
  residentialAddress      ResidentialAddress
  dateOfBirth             DateTime
  driverLicenseNumber     String
  licenseState            AustralianState
  licenseExpiry           DateTime
  position                String?
  // ID Document fields for credit verification
  idDocumentType          String?           // DRIVER_LICENSE | PASSPORT
  idDocumentFrontUrl      String?           // Required for both types
  idDocumentBackUrl       String?           // Required for driver license only
  idDocumentUploadedAt    DateTime?
}

type ResidentialAddress {
  street              String
  suburb              String
  state               String
  postcode            String
  country             String              @default("Australia")
}

type FinancialDetails {
  bankName            String
  accountName         String
  bsb                 String
  accountNumber       String
}

type TradeReference {
  companyName         String
  contactPerson       String
  phone               String
  email               String
  verified            Boolean             @default(false)
  verifiedAt          DateTime?
}

type DeliverySettings {
  warehouseAddress    WarehouseAddress
  mapboxAccessToken   String?
  orderCutoffTime     String              @default("14:00") // HH:mm format
  cutoffByArea        Json?               // Custom cutoff times per area
  defaultDeliveryWindow String?           // e.g., "9:00-17:00"
  minimumOrderAmount  Int?                // In cents, null = no minimum
}

type WarehouseAddress {
  street              String
  suburb              String
  state               String
  postcode            String
  country             String              @default("Australia")
  latitude            Float
  longitude           Float
}

type RouteWaypoint {
  orderId             String              @db.ObjectId
  orderNumber         String
  sequence            Int                 // 1-based position in route
  address             String              // Full formatted address
  suburb              String?             // Suburb name for display
  latitude            Float
  longitude           Float
  estimatedArrival    DateTime?           // Calculated arrival time
  distanceFromPrevious Float?             // Meters from previous waypoint
  durationFromPrevious Int?               // Seconds from previous waypoint
}

type NotificationSettings {
  emailRecipients         String[]            // Array of email addresses
  orderNotifications      OrderNotifications
  inventoryNotifications  InventoryNotifications
  customerNotifications   CustomerNotifications
  quietHoursEnabled       Boolean             @default(false)
  quietHoursStart         String?             // HH:mm format
  quietHoursEnd           String?             // HH:mm format
}

type OrderNotifications {
  newOrder                Boolean             @default(true)
  orderConfirmed          Boolean             @default(true)
  orderDelivered          Boolean             @default(true)
}

type InventoryNotifications {
  lowStock                Boolean             @default(true)
  outOfStock              Boolean             @default(true)
}

type CustomerNotifications {
  newCustomer             Boolean             @default(true)
  creditApplication       Boolean             @default(true)
  creditApproved          Boolean             @default(true)
}

type SmsSettings {
  enabled                 Boolean             @default(false)
  messageTemplate         String?             // SMS template with placeholders: {customerName}, {companyName}
  sendTime                String?             // HH:mm format, e.g. "09:00" (AEST)
}

type SmsReminderPreferences {
  enabled                 Boolean             @default(false)
  reminderDays            String[]            // Array of days: ["monday", "wednesday", etc.]
  lastReminderSentAt      DateTime?           // Track last send to prevent duplicate SMS
}

type PackingSettings {
  quantityPinHash         String?             // SHA-256 hash of 4-digit PIN for quantity modifications
  pinUpdatedAt            DateTime?           // When PIN was last changed
  pinUpdatedBy            String?             // User ID who set the PIN
}

type InventorySettings {
  expiryAlertDays         Int         @default(7)   // Days before expiry to show alerts
}
